/*
 1201
 nmk
 */

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
int main() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);
    vector<int> g;
    
    if( m+k-1 <= n && n <= m*k){
        vector<int> a(n);
        for(int i=0;i<n;i++){
            a[i] = i+1;
        }
        g.push_back(0); // 첫번째 군집의 첫번째 원소 위치(인덱스)
        g.push_back(k); // 첫번째 군집의 마지막 원소 위치+1(인덱스)
        //첫번째 군집: k길이의 감소수열을 만들 범위를 인덱스로 저장
        
        n -= k; // k길이의 첫번째 군집을 만들었으므로 n에서 k개의 길이를 제외
        m--; // 첫번째 군집을 만들었으므로, 증가수열을 구성해야할 m개의 군집 중 1개 제외
        
        int in_cnt = (m==0) ? 0:n/m; // 군집 내 원소 개수 -> n개로 m개의 군집을 만들 때 한 군집에 in_cnt개 만큼 들어간다.
        int r_cnt = (m==0) ? 0:n%m; // 군집을 m개 만들고 r_cnt 개수 만큼 남는다.
        
        for(int i=0;i<m;i++) { // 군집 범위 인덱스 채우기: 첫 번째 군집은 위에서 형성했으므로(g[0],g[1])
           // cout << "gback: "<<g.back() <<" in_cnt:" << in_cnt<<" r? :"<<((r_cnt > 0) ? 1:0)<<endl;
            g.push_back(g.back() + in_cnt + (r_cnt > 0 ? 1:0)); // 나머지 원소들이 있을 경우 각 군집에 할당한다.
            /*이 때 나머지 원소의 수 r_cnt는 군집의 수 m-1보다 절대 많을 수 없다.1)
              그리고, m-1개의 군집 내 원소 개수는 mk=n일 경우를 제외하고 반드시 k보다 한 개이상 적다.2)
              따라서, 나머지 원소들을 m-1개 군집 내 한개씩 할당해도 군집 내 수열의 길이가 k개보다 커지지 않는다는 것을 확신할 수 있다.3)*/
            (r_cnt > 0) ? r_cnt-- : r_cnt; // 나머지가 존재했을 경우, 각 군집에 1개씩 할당했으므로 1개를 제외
        }
        for(int i=0;i<g.size()-1;i++){
            reverse(a.begin()+g[i], a.begin()+g[i+1]);
        }
        for(int i=0;i<a.size();i++){
            cout << a[i] << ' ';
        }
    }else{
        printf("-1\n");
    }
    return 0;
}

/*
 1)
    r_cnt = (n-k)%(m-1) 이므로 제수 m-1보다 항상 작다.
 
 2)
    m+k+1 <= n <= mk를 가정하므로, 최대값 mk일 경우에만 m-1개의 군집 모두가 k개의 원소를 갖는다.
    따라서 n이 최대값 mk보다 작을 경우(m+k+1보다는 크고), m-1개의 각 군집 내에는 k보다 적은 개수를 갖고,
    m-1개보다 작은 r_cnt개의 나머지 원소들이 존재하게 된다.
    이 r_cnt개의 원소들은 군집의 개수 m-1개 보다 수가 적으므로 m-1개의 군집에 각각 한 개씩 할당해주도록 한다.

 3)
    2)의 둘째줄에 설명한 것처럼, m-1개의 각 군집 내에는 k보다 적은 개수가 존재하므로, r_cnt를 m-1개의 군집 각각에 한개씩 할당해도
    m-1개의 군집 내의 원소의 개수(감소수열의 길이)는 절대 k보다 클 수 없다는 것을 확신할 수 있다.
 */
